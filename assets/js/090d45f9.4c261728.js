"use strict";(self.webpackChunklushan_docs=self.webpackChunklushan_docs||[]).push([[650],{3905:function(t,e,a){a.d(e,{Zo:function(){return s},kt:function(){return u}});var n=a(7294);function r(t,e,a){return e in t?Object.defineProperty(t,e,{value:a,enumerable:!0,configurable:!0,writable:!0}):t[e]=a,t}function l(t,e){var a=Object.keys(t);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(t);e&&(n=n.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),a.push.apply(a,n)}return a}function i(t){for(var e=1;e<arguments.length;e++){var a=null!=arguments[e]?arguments[e]:{};e%2?l(Object(a),!0).forEach((function(e){r(t,e,a[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(a)):l(Object(a)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(a,e))}))}return t}function d(t,e){if(null==t)return{};var a,n,r=function(t,e){if(null==t)return{};var a,n,r={},l=Object.keys(t);for(n=0;n<l.length;n++)a=l[n],e.indexOf(a)>=0||(r[a]=t[a]);return r}(t,e);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(t);for(n=0;n<l.length;n++)a=l[n],e.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(t,a)&&(r[a]=t[a])}return r}var p=n.createContext({}),o=function(t){var e=n.useContext(p),a=e;return t&&(a="function"==typeof t?t(e):i(i({},e),t)),a},s=function(t){var e=o(t.components);return n.createElement(p.Provider,{value:e},t.children)},m={inlineCode:"code",wrapper:function(t){var e=t.children;return n.createElement(n.Fragment,{},e)}},k=n.forwardRef((function(t,e){var a=t.components,r=t.mdxType,l=t.originalType,p=t.parentName,s=d(t,["components","mdxType","originalType","parentName"]),k=o(a),u=r,c=k["".concat(p,".").concat(u)]||k[u]||m[u]||l;return a?n.createElement(c,i(i({ref:e},s),{},{components:a})):n.createElement(c,i({ref:e},s))}));function u(t,e){var a=arguments,r=e&&e.mdxType;if("string"==typeof t||r){var l=a.length,i=new Array(l);i[0]=k;var d={};for(var p in e)hasOwnProperty.call(e,p)&&(d[p]=e[p]);d.originalType=t,d.mdxType="string"==typeof t?t:r,i[1]=d;for(var o=2;o<l;o++)i[o]=a[o];return n.createElement.apply(null,i)}return n.createElement.apply(null,a)}k.displayName="MDXCreateElement"},2676:function(t,e,a){a.r(e),a.d(e,{frontMatter:function(){return d},contentTitle:function(){return p},metadata:function(){return o},toc:function(){return s},default:function(){return k}});var n=a(7462),r=a(3366),l=(a(7294),a(3905)),i=["components"],d={},p=void 0,o={unversionedId:"Contracts/Exchange",id:"Contracts/Exchange",isDocsHomePage:!1,title:"Exchange",description:"Structs",source:"@site/docs/Contracts/Exchange.md",sourceDirName:"Contracts",slug:"/Contracts/Exchange",permalink:"/lushan-docs/docs/Contracts/Exchange",editUrl:"https://github.com/perpetual-protocol/lushan-docs/tree/main/docs/Contracts/Exchange.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"ClearingHouseConfig",permalink:"/lushan-docs/docs/Contracts/ClearingHouseConfig"},next:{title:"InsuranceFund",permalink:"/lushan-docs/docs/Contracts/InsuranceFund"}},s=[{value:"Structs",id:"structs",children:[{value:"InternalReplaySwapParams",id:"internalreplayswapparams",children:[]},{value:"InternalSwapResponse",id:"internalswapresponse",children:[]},{value:"InternalRealizePnlParams",id:"internalrealizepnlparams",children:[]}]},{value:"Functions",id:"functions",children:[{value:"initialize",id:"initialize",children:[]},{value:"setAccountBalance",id:"setaccountbalance",children:[]},{value:"setMaxTickCrossedWithinBlock",id:"setmaxtickcrossedwithinblock",children:[]},{value:"uniswapV3SwapCallback",id:"uniswapv3swapcallback",children:[]},{value:"swap",id:"swap",children:[]},{value:"settleFunding",id:"settlefunding",children:[]},{value:"getOrderBook",id:"getorderbook",children:[]},{value:"getAccountBalance",id:"getaccountbalance",children:[]},{value:"getClearingHouseConfig",id:"getclearinghouseconfig",children:[]},{value:"getMaxTickCrossedWithinBlock",id:"getmaxtickcrossedwithinblock",children:[]},{value:"getPnlToBeRealized",id:"getpnltoberealized",children:[]},{value:"getAllPendingFundingPayment",id:"getallpendingfundingpayment",children:[]},{value:"getPendingFundingPayment",id:"getpendingfundingpayment",children:[]},{value:"getSqrtMarkTwapX96",id:"getsqrtmarktwapx96",children:[]}]}],m={toc:s};function k(t){var e=t.components,a=(0,r.Z)(t,i);return(0,l.kt)("wrapper",(0,n.Z)({},m,a,{components:e,mdxType:"MDXLayout"}),(0,l.kt)("h2",{id:"structs"},"Structs"),(0,l.kt)("h3",{id:"internalreplayswapparams"},"InternalReplaySwapParams"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"  struct InternalReplaySwapParams(\n    address baseToken\n    bool isBaseToQuote\n    bool isExactInput\n    uint256 amount\n    uint160 sqrtPriceLimitX96\n  )\n")),(0,l.kt)("h3",{id:"internalswapresponse"},"InternalSwapResponse"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"  struct InternalSwapResponse(\n    int256 base\n    int256 quote\n    int256 exchangedPositionSize\n    int256 exchangedPositionNotional\n    uint256 fee\n    uint256 insuranceFundFee\n    int24 tick\n  )\n")),(0,l.kt)("h3",{id:"internalrealizepnlparams"},"InternalRealizePnlParams"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"  struct InternalRealizePnlParams(\n    address trader\n    address baseToken\n    int256 takerPositionSize\n    int256 takerOpenNotional\n    int256 base\n    int256 quote\n  )\n")),(0,l.kt)("h2",{id:"functions"},"Functions"),(0,l.kt)("h3",{id:"initialize"},"initialize"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"  function initialize(\n  ) external\n")),(0,l.kt)("h3",{id:"setaccountbalance"},"setAccountBalance"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"  function setAccountBalance(\n    address AccountBalance\n  ) external\n")),(0,l.kt)("h4",{id:"parameters"},"Parameters:"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:"left"},"Name"),(0,l.kt)("th",{parentName:"tr",align:"left"},"Type"),(0,l.kt)("th",{parentName:"tr",align:"left"},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},(0,l.kt)("inlineCode",{parentName:"td"},"AccountBalance")),(0,l.kt)("td",{parentName:"tr",align:"left"},"address"),(0,l.kt)("td",{parentName:"tr",align:"left"},"contract address")))),(0,l.kt)("h3",{id:"setmaxtickcrossedwithinblock"},"setMaxTickCrossedWithinBlock"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"  function setMaxTickCrossedWithinBlock(\n    address baseToken,\n    uint24 maxTickCrossedWithinBlock\n  ) external\n")),(0,l.kt)("p",null,"Restrict the price impact by setting the ticks can be crossed within a block when\ntrader reducing liquidity. It is used to prevent the malicious behavior of the malicious traders.\nThe restriction is applied in _isOverPriceLimitWithTick()"),(0,l.kt)("h4",{id:"parameters-1"},"Parameters:"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:"left"},"Name"),(0,l.kt)("th",{parentName:"tr",align:"left"},"Type"),(0,l.kt)("th",{parentName:"tr",align:"left"},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},(0,l.kt)("inlineCode",{parentName:"td"},"baseToken")),(0,l.kt)("td",{parentName:"tr",align:"left"},"address"),(0,l.kt)("td",{parentName:"tr",align:"left"},"The base token address")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},(0,l.kt)("inlineCode",{parentName:"td"},"maxTickCrossedWithinBlock")),(0,l.kt)("td",{parentName:"tr",align:"left"},"uint24"),(0,l.kt)("td",{parentName:"tr",align:"left"},"The maximum ticks can be crossed within a block")))),(0,l.kt)("h3",{id:"uniswapv3swapcallback"},"uniswapV3SwapCallback"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"  function uniswapV3SwapCallback(\n    int256 amount0Delta,\n    int256 amount1Delta,\n    bytes data\n  ) external\n")),(0,l.kt)("p",null,"Called to ",(0,l.kt)("inlineCode",{parentName:"p"},"msg.sender")," after executing a swap via IUniswapV3Pool#swap."),(0,l.kt)("p",null,"This callback is forwarded to ClearingHouse.uniswapV3SwapCallback() because all the tokens\nare stored in there."),(0,l.kt)("h4",{id:"parameters-2"},"Parameters:"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:"left"},"Name"),(0,l.kt)("th",{parentName:"tr",align:"left"},"Type"),(0,l.kt)("th",{parentName:"tr",align:"left"},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},(0,l.kt)("inlineCode",{parentName:"td"},"amount0Delta")),(0,l.kt)("td",{parentName:"tr",align:"left"},"int256"),(0,l.kt)("td",{parentName:"tr",align:"left"},"The amount of token0 that was sent (negative) or must be received (positive) by the pool by")))),(0,l.kt)("p",null,"the end of the swap. If positive, the callback must send that amount of token0 to the pool.\n|",(0,l.kt)("inlineCode",{parentName:"p"},"amount1Delta")," | int256 | The amount of token1 that was sent (negative) or must be received (positive) by the pool by\nthe end of the swap. If positive, the callback must send that amount of token1 to the pool.\n|",(0,l.kt)("inlineCode",{parentName:"p"},"data")," | bytes | Any data passed through by the caller via the IUniswapV3PoolActions#swap call"),(0,l.kt)("h3",{id:"swap"},"swap"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"  function swap(\n    struct IExchange.SwapParams params\n  ) external returns (struct IExchange.SwapResponse)\n")),(0,l.kt)("p",null,"can only be called from ClearingHouse"),(0,l.kt)("h4",{id:"parameters-3"},"Parameters:"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:"left"},"Name"),(0,l.kt)("th",{parentName:"tr",align:"left"},"Type"),(0,l.kt)("th",{parentName:"tr",align:"left"},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},(0,l.kt)("inlineCode",{parentName:"td"},"params")),(0,l.kt)("td",{parentName:"tr",align:"left"},"struct IExchange.SwapParams"),(0,l.kt)("td",{parentName:"tr",align:"left"},"The parameters of the swap")))),(0,l.kt)("h4",{id:"return-values"},"Return Values:"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:"left"},"Name"),(0,l.kt)("th",{parentName:"tr",align:"left"},"Type"),(0,l.kt)("th",{parentName:"tr",align:"left"},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},(0,l.kt)("inlineCode",{parentName:"td"},"The")),(0,l.kt)("td",{parentName:"tr",align:"left"},"struct IExchange.SwapParams"),(0,l.kt)("td",{parentName:"tr",align:"left"},"result of the swap")))),(0,l.kt)("h3",{id:"settlefunding"},"settleFunding"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"  function settleFunding(\n  ) external returns (int256 fundingPayment, struct Funding.Growth fundingGrowthGlobal)\n")),(0,l.kt)("p",null,"Settle the funding payment for the time interval since the last settlement"),(0,l.kt)("p",null,"This function should be called at the beginning of every high-level function, such as openPosition()\nwhile it doesn't matter who calls this function\nthis function 1. settles personal funding payment 2. updates global funding growth\npersonal funding payment is settled whenever there is pending funding payment\nthe global funding growth update only happens once per unique timestamp (not blockNumber, due to Arbitrum)"),(0,l.kt)("h4",{id:"return-values-1"},"Return Values:"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:"left"},"Name"),(0,l.kt)("th",{parentName:"tr",align:"left"},"Type"),(0,l.kt)("th",{parentName:"tr",align:"left"},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},(0,l.kt)("inlineCode",{parentName:"td"},"fundingPayment")),(0,l.kt)("td",{parentName:"tr",align:"left"},"address"),(0,l.kt)("td",{parentName:"tr",align:"left"},"the funding payment of a trader in one market should be settled into owned realized Pnl")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},(0,l.kt)("inlineCode",{parentName:"td"},"fundingGrowthGlobal")),(0,l.kt)("td",{parentName:"tr",align:"left"},"address"),(0,l.kt)("td",{parentName:"tr",align:"left"},"the up-to-date globalFundingGrowth, usually used for later calculations")))),(0,l.kt)("h3",{id:"getorderbook"},"getOrderBook"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"  function getOrderBook(\n  ) external returns (address)\n")),(0,l.kt)("p",null,"Get ",(0,l.kt)("inlineCode",{parentName:"p"},"OrderBook")," contract address"),(0,l.kt)("h4",{id:"return-values-2"},"Return Values:"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:"left"},"Name"),(0,l.kt)("th",{parentName:"tr",align:"left"},"Type"),(0,l.kt)("th",{parentName:"tr",align:"left"},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},(0,l.kt)("inlineCode",{parentName:"td"},"orderBook")),(0,l.kt)("td",{parentName:"tr",align:"left"}),(0,l.kt)("td",{parentName:"tr",align:"left"},(0,l.kt)("inlineCode",{parentName:"td"},"OrderBook")," contract address")))),(0,l.kt)("h3",{id:"getaccountbalance"},"getAccountBalance"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"  function getAccountBalance(\n  ) external returns (address)\n")),(0,l.kt)("p",null,"Get ",(0,l.kt)("inlineCode",{parentName:"p"},"AccountBalance")," contract address"),(0,l.kt)("h4",{id:"return-values-3"},"Return Values:"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:"left"},"Name"),(0,l.kt)("th",{parentName:"tr",align:"left"},"Type"),(0,l.kt)("th",{parentName:"tr",align:"left"},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},(0,l.kt)("inlineCode",{parentName:"td"},"accountBalance")),(0,l.kt)("td",{parentName:"tr",align:"left"}),(0,l.kt)("td",{parentName:"tr",align:"left"},(0,l.kt)("inlineCode",{parentName:"td"},"AccountBalance")," contract address")))),(0,l.kt)("h3",{id:"getclearinghouseconfig"},"getClearingHouseConfig"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"  function getClearingHouseConfig(\n  ) external returns (address)\n")),(0,l.kt)("p",null,"Get ",(0,l.kt)("inlineCode",{parentName:"p"},"ClearingHouseConfig")," contract address"),(0,l.kt)("h4",{id:"return-values-4"},"Return Values:"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:"left"},"Name"),(0,l.kt)("th",{parentName:"tr",align:"left"},"Type"),(0,l.kt)("th",{parentName:"tr",align:"left"},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},(0,l.kt)("inlineCode",{parentName:"td"},"clearingHouse")),(0,l.kt)("td",{parentName:"tr",align:"left"}),(0,l.kt)("td",{parentName:"tr",align:"left"},(0,l.kt)("inlineCode",{parentName:"td"},"ClearingHouseConfig")," contract address")))),(0,l.kt)("h3",{id:"getmaxtickcrossedwithinblock"},"getMaxTickCrossedWithinBlock"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"  function getMaxTickCrossedWithinBlock(\n    address baseToken\n  ) external returns (uint24)\n")),(0,l.kt)("p",null,"Get the max ticks allowed to be crossed within a block when reducing position"),(0,l.kt)("h4",{id:"parameters-4"},"Parameters:"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:"left"},"Name"),(0,l.kt)("th",{parentName:"tr",align:"left"},"Type"),(0,l.kt)("th",{parentName:"tr",align:"left"},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},(0,l.kt)("inlineCode",{parentName:"td"},"baseToken")),(0,l.kt)("td",{parentName:"tr",align:"left"},"address"),(0,l.kt)("td",{parentName:"tr",align:"left"},"Address of the base token")))),(0,l.kt)("h4",{id:"return-values-5"},"Return Values:"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:"left"},"Name"),(0,l.kt)("th",{parentName:"tr",align:"left"},"Type"),(0,l.kt)("th",{parentName:"tr",align:"left"},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},(0,l.kt)("inlineCode",{parentName:"td"},"maxTickCrossedWithinBlock")),(0,l.kt)("td",{parentName:"tr",align:"left"},"address"),(0,l.kt)("td",{parentName:"tr",align:"left"},"The max ticks allowed to be crossed within a block when reducing position")))),(0,l.kt)("h3",{id:"getpnltoberealized"},"getPnlToBeRealized"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"  function getPnlToBeRealized(\n    struct IExchange.RealizePnlParams params\n  ) external returns (int256)\n")),(0,l.kt)("p",null,"Get the pnl that can be realized if trader reduce position"),(0,l.kt)("p",null,"This function normally won't be needed by traders, but it might be useful for 3rd party"),(0,l.kt)("h4",{id:"parameters-5"},"Parameters:"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:"left"},"Name"),(0,l.kt)("th",{parentName:"tr",align:"left"},"Type"),(0,l.kt)("th",{parentName:"tr",align:"left"},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},(0,l.kt)("inlineCode",{parentName:"td"},"params")),(0,l.kt)("td",{parentName:"tr",align:"left"},"struct IExchange.RealizePnlParams"),(0,l.kt)("td",{parentName:"tr",align:"left"},"The params needed to do the query, encoded as ",(0,l.kt)("inlineCode",{parentName:"td"},"RealizePnlParams")," in calldata")))),(0,l.kt)("h4",{id:"return-values-6"},"Return Values:"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:"left"},"Name"),(0,l.kt)("th",{parentName:"tr",align:"left"},"Type"),(0,l.kt)("th",{parentName:"tr",align:"left"},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},(0,l.kt)("inlineCode",{parentName:"td"},"pnlToBeRealized")),(0,l.kt)("td",{parentName:"tr",align:"left"},"struct IExchange.RealizePnlParams"),(0,l.kt)("td",{parentName:"tr",align:"left"},"The pnl that can be realized if trader reduce position")))),(0,l.kt)("h3",{id:"getallpendingfundingpayment"},"getAllPendingFundingPayment"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"  function getAllPendingFundingPayment(\n  ) external returns (int256 pendingFundingPayment)\n")),(0,l.kt)("p",null,"Get all the pending funding payment for a trader"),(0,l.kt)("h4",{id:"return-values-7"},"Return Values:"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:"left"},"Name"),(0,l.kt)("th",{parentName:"tr",align:"left"},"Type"),(0,l.kt)("th",{parentName:"tr",align:"left"},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},(0,l.kt)("inlineCode",{parentName:"td"},"pendingFundingPayment")),(0,l.kt)("td",{parentName:"tr",align:"left"},"address"),(0,l.kt)("td",{parentName:"tr",align:"left"},"The pending funding payment of the trader.")))),(0,l.kt)("p",null,"Positive value means the trader pays funding, negative value means the trader receives funding."),(0,l.kt)("h3",{id:"getpendingfundingpayment"},"getPendingFundingPayment"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"  function getPendingFundingPayment(\n  ) public returns (int256)\n")),(0,l.kt)("p",null,"Get the pending funding payment for a trader in a given market"),(0,l.kt)("p",null,"this is the view version of _updateFundingGrowth()"),(0,l.kt)("h4",{id:"return-values-8"},"Return Values:"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:"left"},"Name"),(0,l.kt)("th",{parentName:"tr",align:"left"},"Type"),(0,l.kt)("th",{parentName:"tr",align:"left"},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},(0,l.kt)("inlineCode",{parentName:"td"},"pendingFundingPayment")),(0,l.kt)("td",{parentName:"tr",align:"left"},"address"),(0,l.kt)("td",{parentName:"tr",align:"left"},"The pending funding payment of a trader in one market,")))),(0,l.kt)("p",null,"including liquidity & balance coefficients. Positive value means the trader pays funding,\nnegative value means the trader receives funding."),(0,l.kt)("h3",{id:"getsqrtmarktwapx96"},"getSqrtMarkTwapX96"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-solidity"},"  function getSqrtMarkTwapX96(\n    address baseToken,\n    uint32 twapInterval\n  ) public returns (uint160)\n")),(0,l.kt)("p",null,"Get the square root of the market twap price with the given time interval"),(0,l.kt)("p",null,"The return value is a X96 number"),(0,l.kt)("h4",{id:"parameters-6"},"Parameters:"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:"left"},"Name"),(0,l.kt)("th",{parentName:"tr",align:"left"},"Type"),(0,l.kt)("th",{parentName:"tr",align:"left"},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},(0,l.kt)("inlineCode",{parentName:"td"},"baseToken")),(0,l.kt)("td",{parentName:"tr",align:"left"},"address"),(0,l.kt)("td",{parentName:"tr",align:"left"},"Address of the base token")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},(0,l.kt)("inlineCode",{parentName:"td"},"twapInterval")),(0,l.kt)("td",{parentName:"tr",align:"left"},"uint32"),(0,l.kt)("td",{parentName:"tr",align:"left"},"The time interval in seconds")))),(0,l.kt)("h4",{id:"return-values-9"},"Return Values:"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:"left"},"Name"),(0,l.kt)("th",{parentName:"tr",align:"left"},"Type"),(0,l.kt)("th",{parentName:"tr",align:"left"},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:"left"},(0,l.kt)("inlineCode",{parentName:"td"},"sqrtMarkTwapX96")),(0,l.kt)("td",{parentName:"tr",align:"left"},"address"),(0,l.kt)("td",{parentName:"tr",align:"left"},"The square root of the market twap price")))))}k.isMDXComponent=!0}}]);